You are working in the repo `fpl-radar`.

Implement **Engine v1.2: Replace `selected_by_percent` as a primary signal with market momentum (transfers in/out), fixtures, and league ownership + risk profile**.

## Goal
Update the prediction engine so BUY and SELL ranking are driven primarily by:
- **Market momentum this GW**:
  - `transfers_in_event` (buy)
  - `transfers_out_event` (sell)
- **Upcoming fixtures** (team-level lookahead score from Engine v1.1 Step 2)
- **League ownership** (mini-league-specific, from Engine v1.1 Step 3)
- A **riskProfile toggle** that changes how league ownership is used:
  - `safe`: prefer high-league-owned buys, avoid selling high-league-owned players
  - `balanced`: mild version of safe
  - `risky`: prefer low-league-owned buys (differentials), reduce “don’t sell high-owned” penalty

We still keep availability penalties and keep the model explainable.

We are intentionally de-emphasising `selected_by_percent` because dead teams make it noisy.

---

## Scope
- Update bootstrap ingestion to persist `transfers_in_event` and `transfers_out_event` onto `FplPlayer`
- Add a “momentum normalisation” helper (log/percentile-based)
- Update BUY scoring (#14) to use:
  - transfers_in_event + upcoming fixtures + league ownership (riskProfile)
- Update SELL scoring (#13) to use:
  - transfers_out_event + upcoming fixtures + league ownership (riskProfile)
- Plumb `riskProfile` into:
  - scripts (`predict:buys`, `predict:sells`, `predict:transfers`)
  - core scoring functions (default = `balanced`)
  - (optional) API endpoints (#18) via query param `riskProfile=safe|balanced|risky`

Do NOT:
- Add ML
- Add historical player performance
- Add formation-change logic
- Remove `selectedByPercent` from DB (just stop using it as primary)

---

## Deliverables

### A) DB fields for market momentum
Update Prisma `FplPlayer` to include:
- `transfersInEvent` Int @default(0)
- `transfersOutEvent` Int @default(0)

Migration:
`pnpm exec prisma migrate dev --name player_transfer_momentum`

Update bootstrap ingestion (Issue #8 ingest):
- When mapping player elements from `/api/bootstrap-static/`, persist:
  - `transfers_in_event` -> `transfersInEvent`
  - `transfers_out_event` -> `transfersOutEvent`

---

### B) Add risk profile type
Create:
- `src/prediction/riskProfile.ts`

```ts
export type RiskProfile = "safe" | "balanced" | "risky";

export function parseRiskProfile(input: unknown): RiskProfile {
  return input === "safe" || input === "risky" ? input : "balanced";
}
```

C) Momentum normalisation helper

Create:

- src/prediction/momentum/normalise.ts

Export:
```ts
export function normaliseMomentum(params: {
  value: number;      // transfers in/out this GW
  p95: number;        // 95th percentile across player pool
}): number; // 0..1
```

Use a robust log scale:

- m = log(1+value) / log(1+p95)

- clamp to [0,1]

Add helper to compute p95 from a list of numbers:
```ts
export function percentile(values: number[], p: number): number;
```

Then create:

- src/prediction/momentum/p95.ts

Export:
```ts
export async function loadMomentumP95(): Promise<{ inP95: number; outP95: number }>
```

Implementation:

- Query DB for all players’ transfersInEvent, transfersOutEvent

- Compute p95 for each

- Cache in-process (module-level) for the request lifetime

- Optional: cache in Redis for 60s if already available


D) Update BUY scoring to use new signals

Update:

- src/prediction/buyScoring/types.ts
Add to features:

- transfersInEvent: number

- momentumIn: number (0..1)

- upcomingFixtureScore: number | null (already from v1.1 step 2)

- leagueOwnershipPct: number | null (already from v1.1 step 3)

Update BUY constants:

- src/prediction/buyScoring/constants.ts

Replace primary weights with:
```ts
export const BUY_SCORE = {
  BASE: 0,
  W_MOMENTUM: 50,
  W_FIXTURES: 35,
  W_LEAGUE_OWNERSHIP: 15, // used differently based on riskProfile
  MOMENTUM_POOL_LIMIT: 600, // candidate pool size
  // keep availability penalties:
  FLAGGED_PENALTY: 50,
  UNAVAILABLE_PENALTY: 80,
} as const;
```

Scoring logic in buyScoring/score.ts:

1. Compute momentumIn using p95 helper:

- momentumIn = normaliseMomentum({ value: transfersInEvent, p95: inP95 })

2. Convert upcoming fixture score to 0..1:

- create helper normaliseFixtureScore(score: number | null): number:

- - if null -> 0.5 (neutral)

- - else map your clamp range into [0,1]

3. League term depends on riskProfile:

- if leagueOwnershipPct is null: treat as 0

- safe: leagueTerm = L

- balanced: leagueTerm = 0.5*L

- risky: leagueTerm = (1 - L) (differential preference)

4. Score:

- raw = W_MOMENTUM*momentumIn + W_FIXTURES*fixture01 + W_LEAGUE_OWNERSHIP*leagueTerm

- Apply availability penalties

- Clamp to [0,100]

Reasons:

- If momentumIn high (>0.7): "High transfers in this GW"

- If fixtures good (>0.7): "Favourable upcoming fixtures"

- If safe and L high (>0.6): "Highly owned in your league"

- If risky and L low (<0.2): "Strong differential in your league"

Stop using selectedByPercent as a primary signal.
(You may keep it as a weak tie-breaker only if desired; otherwise remove usage entirely.)


E) Update SELL scoring to use new signals

Update:

- src/prediction/sellScoring/types.ts
Add features:

- transfersOutEvent: number

- momentumOut: number (0..1)

- upcomingFixtureScore: number | null

- leagueOwnershipPct: number | null (new for sell too)

Implement computeLeagueOwnership is already available; reuse it for sell scoring (owned players).

Update SELL constants:
```ts
export const SELL_SCORE = {
  BASE: 0,
  W_MOMENTUM: 50,
  W_FIXTURES: 35,
  W_LEAGUE_OWNERSHIP: 15, // applied as a penalty in safe/balanced
  FLAGGED_BONUS: 40,
  UNAVAILABLE_BONUS: 60,
} as const;
```

Scoring logic:

1. momentumOut = normaliseMomentum({ value: transfersOutEvent, p95: outP95 })

2. Convert fixtures to “badness” 0..1:

- fixtureBad01 = 1 - fixtureGood01

3. League term depends on riskProfile:

- safe: leaguePenalty = L

- balanced: leaguePenalty = 0.5*L

- risky: leaguePenalty = 0.1*L (nearly ignore)

4. Score:

- raw = W_MOMENTUM*momentumOut + W_FIXTURES*fixtureBad01 - W_LEAGUE_OWNERSHIP*leaguePenalty

- Add availability/flag bonuses

- Clamp [0,100]

Reasons:

- momentumOut high: "High transfers out this GW"

- bad fixtures: "Difficult upcoming fixtures"

- safe & L high causing penalty: "Widely owned in your league (less urgency to sell)"

Remove bench influence (should already be done in v1.1 step 1).


F) Plumb riskProfile through prediction pipeline

Update signatures:

- scoreBuyCandidates({ ..., riskProfile?: RiskProfile })

- scoreSellCandidates({ ..., riskProfile?: RiskProfile })

- predictTransfersForEntry({ ..., riskProfile?: RiskProfile })

Default riskProfile: balanced.

Update scripts:

- predict:buys, predict:sells, predict:transfers
Support env var:

- FPL_RISK_PROFILE=safe|balanced|risky

Update API (optional but recommended):

- GET /league/:leagueId/entry/:entryId/predictions?riskProfile=safe|balanced|risky
Use parseRiskProfile.


G) Tests

Add unit tests:

- normaliseMomentum:

- - value=0 => 0

- - value=p95 => ~1

- - value>p95 => 1

- BUY scoring:

- - safe ranks higher leagueOwnershipPct higher (given equal other metrics)

- - risky ranks lower leagueOwnershipPct higher (prefer differential)

- SELL scoring:

- safe penalises selling high leagueOwnershipPct more than risky

Keep tests pure by factoring scoring into helpers that accept features directly.

Acceptance Criteria

- Bootstrap ingestion persists transfersInEvent/transfersOutEvent

- BUY and SELL rankings are primarily driven by:

- - transfers_in/out_event

- - upcoming fixtures

- - league ownership + riskProfile

- selected_by_percent is no longer a primary ranking term

- riskProfile changes outputs in intuitive ways:

- - safe: coverage/high-league-owned buys preferred, high-owned sells discouraged

- - risky: differential buys preferred, high-owned sell penalty reduced

- Scripts and (optionally) API accept riskProfile

Implementation Order

- Prisma fields + migration

- Bootstrap ingest mapping for momentum fields

- Momentum normalisation helper + p95 loader

- Update BUY scoring + tests

- Update SELL scoring + tests

- Plumb riskProfile through predict pipeline + scripts (+ API optional)

Do all work directly in the repo with small, well-named modules and explainable reasons.