You are working in the repo `fpl-radar`.

Implement Issue #10: Fetch and store entry picks for the current gameweek (squad snapshots) for all entries in a league.

This builds on:
- Issue #7: `FplClient` exists
- Issue #8: reference tables exist (teams/players/positions/gameweeks + snapshot table)
- Issue #9: league + league entries are persisted

## Goal
Given a `leagueId`, fetch each league entry’s picks for a target gameweek and persist a “squad snapshot” that includes:
- the 15 picked players (element ids)
- starting XI vs bench order
- captain/vice captain flags
- entry history values that matter for transfers (bank, value, free transfers if available)
- timestamps for when the snapshot was fetched

The pipeline must:
- handle many entries efficiently (concurrency limit)
- be idempotent (upsert per entry+gameweek)
- tolerate partial failures (continue if 1 entry fails, record error)
- be runnable via a script now, and reusable from the worker later

Do NOT implement prediction logic yet.

---

## Important API notes
The public endpoint needed:
- `GET /api/entry/{entryId}/event/{eventId}/picks/`

This typically includes:
- `picks[]` with `{ element, position, is_captain, is_vice_captain, multiplier }`
- `entry_history` with values like `bank`, `value`, `event_transfers`, `event_transfers_cost`, etc.
Field names may differ slightly; use Zod to validate only what you need and allow passthrough for unknown fields.

Also:
- Determine `eventId` (gameweek) from `bootstrap-static` events where `is_next` or `is_current` depending on time.
Default behaviour:
- Use `is_next === true` gameweek as “upcoming deadline”
- If none, fall back to `is_current` or latest unfinished
Allow overriding with `FPL_EVENT_ID` env var.

---

## Deliverables

### A) Prisma schema changes
Add models:

#### 1) `FplEntrySnapshot`
Represents one entry’s squad state for a given gameweek.
Fields:
- `id` String @id @default(cuid())
- `leagueId` Int  (FK -> FplLeague)
- `entryId` Int   (FK -> FplLeagueEntry via id; or keep as scalar if you prefer)
- `eventId` Int   (FK -> FplGameweek)
- `bank` Int?     (tenths; from entry_history.bank)
- `teamValue` Int? (tenths; from entry_history.value)
- `eventTransfers` Int? (optional)
- `eventTransfersCost` Int? (optional)
- `fetchedAt` DateTime @default(now())
- `createdAt` DateTime @default(now())
- `updatedAt` DateTime @updatedAt

Constraints:
- Unique composite: `(leagueId, entryId, eventId)`

Indexes:
- `(leagueId, eventId)`
- `(entryId, eventId)`

#### 2) `FplEntryPick`
Represents the 15 picks belonging to a snapshot.
Fields:
- `id` String @id @default(cuid())
- `snapshotId` String (FK -> FplEntrySnapshot)
- `playerId` Int (FK -> FplPlayer id / FPL element id)
- `pickPosition` Int (1..15 as returned by FPL)
- `multiplier` Int
- `isCaptain` Boolean
- `isViceCaptain` Boolean

Constraints:
- Unique composite: `(snapshotId, pickPosition)`
- Optional: Unique composite `(snapshotId, playerId)` (careful: in rare data bugs duplicates could exist)

Relation:
- Snapshot 1 → many Picks with cascade delete

After schema updates, run:
```bash
pnpm exec prisma migrate dev --name fpl_entry_snapshots
```

B) Zod schema for picks endpoint

Create:

src/fpl/schemas/entryPicks.schema.ts

Validate minimum needed:

picks: array of objects with:

- element (number)

- position (number)

- multiplier (number)

- is_captain (boolean)

- is_vice_captain (boolean)

entry_history: object with (all optional):

- bank (number)

- value (number)

- event_transfers (number)

- event_transfers_cost (number)

Export types.

Extend FplClient with:

getEntryPicks(params: { entryId: number; eventId: number }): Promise<EntryPicksResponse>

Use caching:

cache key: entry:{entryId}:event:{eventId}:picks

TTL: 60 seconds for current/next GW; 6 hours for finished GWs (simple rule: if event finished => long TTL)

C) Ingestion logic

Create:

src/ingestion/entryPicksIngestion.ts

Export:

ingestLeagueEntryPicks(params: {
  leagueId: number;
  eventId?: number;
  concurrency?: number; // default 5
  logger: Logger;
}): Promise<{
  leagueId: number;
  eventId: number;
  processed: number;
  succeeded: number;
  failed: number;
}>

Responsibilities:

Resolve eventId if not provided:

read from env FPL_EVENT_ID if present

else use FplClient.getBootstrapStatic() events:

prefer is_next

else is_current

Load league entries from DB for that leagueId (from Issue #9)

For each entryId:

fetch picks via FplClient.getEntryPicks({ entryId, eventId })

upsert FplEntrySnapshot (unique by leagueId+entryId+eventId)

replace associated picks:

simplest: delete existing FplEntryPick rows for snapshotId and insert new 15 rows

do this inside a transaction per entry

Concurrency control:

implement a simple promise pool (no new deps required) OR use p-limit

default concurrency = 5

Partial failure handling:

if one entry fails, log error and continue

track success/fail counts

Return summary

Do NOT:

compute transfer predictions

fetch transfers history here

Optional but useful:

Store a per-entry error record in a simple table IngestionError (only if you feel it’s necessary; otherwise just log)

D) Script

Create:

src/scripts/ingest-entry-picks.ts

Behaviour:

load env (dotenv/config)

read FPL_LEAGUE_ID (required)

optionally read FPL_EVENT_ID

call ingestLeagueEntryPicks({ leagueId, eventId })

print summary counts

Add script:

"ingest:entry-picks": "tsx src/scripts/ingest-entry-picks.ts"
Acceptance Criteria

Running pnpm ingest:entry-picks:

fetches picks for each entry in the league

writes one snapshot per entry for the resolved eventId

writes 15 pick rows per snapshot

Re-running the command updates snapshots and replaces picks without duplicates

Works when Redis is disabled (falls back to memory cache)

If 1 entry fails, the pipeline continues and reports failures

Concurrency is respected (no unbounded parallelism)

Implementation Order

Prisma schema + migration

Add schema + FplClient.getEntryPicks

Implement ingestion module with concurrency + upsert/replace strategy

Add script + run locally

Verify in DB: snapshots count == league entries count (or less if failures)

Keep scope limited to entry picks ingestion only.

::contentReference[oaicite:0]{index=0}