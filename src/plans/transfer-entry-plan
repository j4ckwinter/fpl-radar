You are working in the repo `fpl-radar`.

Implement Issue #11: Fetch and store entry transfer history (public endpoint) and derive a lightweight behaviour profile per entry.

This builds on:
- Issue #7: `FplClient` exists and has HTTP/caching/Zod patterns
- Issue #8: reference tables exist
- Issue #9: league + league entries persisted
- Issue #10: entry snapshots/picks persisted (optional dependency, but useful)

## Goal
For each entry (manager) in a league:
1) Fetch their transfer history via public FPL API
2) Persist raw transfer events (structured, queryable)
3) Derive and store a simple `behaviour profile` used later in rival transfer prediction (risk appetite etc.)

The pipeline must:
- handle many entries efficiently with a concurrency limit
- be idempotent (no duplicate transfers)
- tolerate partial failures (continue if an entry fails)
- be runnable via a script now and reusable by a worker later

Do NOT implement prediction logic yet.

---

## FPL endpoints required
Public transfers endpoint:
- `GET /api/entry/{entryId}/transfers/`

This returns an array of transfer records. Typical fields include:
- `element_in`, `element_out` (player ids)
- `event` (gameweek)
- `time` (timestamp)
- `value`, `bank` (ints in tenths)
- `cost` (hit cost for that transfer batch; may be repeated)
- `points` / `points_on_bench` sometimes appear depending on season

Treat upstream fields defensively. Validate only what you need.

---

## Deliverables

### A) Prisma schema changes
Add models:

#### 1) `FplEntryTransfer`
Represents a single recorded transfer action for an entry.
Fields:
- `id` String @id @default(cuid())
- `entryId` Int
- `eventId` Int
- `time` DateTime
- `playerInId` Int
- `playerOutId` Int
- `value` Int?        (team value after transfer, tenths)
- `bank` Int?         (bank after transfer, tenths)
- `cost` Int?         (hit cost associated, if present)
- `createdAt` DateTime @default(now())

Constraints:
- Unique composite to prevent duplicates:
  - `(entryId, eventId, time, playerInId, playerOutId)`
Indexes:
- `(entryId, eventId)`
- `(playerInId)`
- `(playerOutId)`

Foreign keys:
- `entryId` → `FplLeagueEntry.id` (or keep scalar if relation is awkward)
- `eventId` → `FplGameweek.id`
- `playerInId/playerOutId` → `FplPlayer.id`

#### 2) `FplEntryBehaviourProfile`
Derived stats used for later prediction weighting.
Fields:
- `entryId` Int @id
- `transfersCount` Int
- `hitsCount` Int                 (number of times cost > 0)
- `totalHitCost` Int              (sum of costs)
- `avgTransfersPerGw` Float
- `hitRate` Float                 (hitsCount / number of active GWs with transfers)
- `lastTransferAt` DateTime?
- `updatedAt` DateTime @updatedAt

Optional extra (nice but not required):
- `earlyTransferRate` Float (transfers made >24h before deadline vs late; only if deadlines available)

Run migration:
```bash
pnpm exec prisma migrate dev --name fpl_entry_transfers
```

B) Zod schema + FplClient method

Create:

- src/fpl/schemas/entryTransfers.schema.ts

Validate a transfer item minimally:

- element_in number

- element_out number

- event number

- time string (ISO datetime)

- optional value, bank, cost numbers

Extend FplClient with:

- getEntryTransfers(params: { entryId: number }): Promise<EntryTransfersItem[]>

Caching:

- transfers change often near deadline; use TTL ~5 minutes

- cache key: entry:{entryId}:transfers

C) Ingestion logic

Create:

- src/ingestion/entryTransfersIngestion.ts

Export:

ingestLeagueEntryTransfers(params: {
  leagueId: number;
  concurrency?: number; // default 5
  logger: Logger;
}): Promise<{
  leagueId: number;
  processed: number;
  succeeded: number;
  failed: number;
  insertedTransfers: number;
  updatedProfiles: number;
}>

Responsibilities:

1) Load league entries from DB for leagueId

2) For each entry:

- Fetch transfers from FPL

- Upsert transfers into DB:

- - Use createMany({ skipDuplicates: true }) where possible

- - Ensure unique composite prevents duplicates

- Derive behaviour profile:

- - transfersCount = total transfers rows for that entry

- - hitsCount = count of distinct transfer timestamps (or groups) where cost > 0 OR count of transfers with cost > 0 (pick one and document)

- - totalHitCost = sum of cost (avoid double-counting: group by (eventId,time) and take max cost per group if cost repeats)

- - avgTransfersPerGw = transfersCount / number of distinct events with any transfer

- - hitRate = hitsCount / number of distinct events with transfers

- - lastTransferAt = max(time)

- Upsert FplEntryBehaviourProfile for entry

3) Concurrency control (promise pool or p-limit)

4) Partial failure handling: continue on errors, log and count failures

Important:

Prevent double-counting hit costs by grouping transfers by (eventId, time). For each group, cost is the group’s hit cost; use max(cost) in the group.

Keep logic readable: write helper functions groupTransfers, computeProfile.

Do NOT:

infer future transfers

fetch picks here (already done in Issue #10)

store “free transfers remaining” (not reliably available from public endpoints)

D) Script

Create:

- src/scripts/ingest-entry-transfers.ts

Behaviour:

- load env (dotenv/config)

- require FPL_LEAGUE_ID

- call ingestLeagueEntryTransfers

- print summary counts

Add script:

"ingest:entry-transfers": "tsx src/scripts/ingest-entry-transfers.ts"

Acceptance Criteria

- Running pnpm ingest:entry-transfers:

- - fetches transfers for each entry in the league

- - inserts transfer rows without duplicates

- - creates/updates one behaviour profile per entry

- Re-running is idempotent (no duplicate transfer rows; profiles recompute cleanly)

- Works with Redis disabled (memory cache fallback)

- If one entry fails, continues and reports failure count

- Behaviour profile avoids double-counting hit costs (grouping logic)

Implementation Order

1) Prisma schema + migration

2) Add Zod schema + FplClient.getEntryTransfers

3) Implement ingestion module + profile derivation

4) Add script and run locally

5) Validate in DB:

- transfers exist for at least one entry

- profiles populated and reasonable

- Keep scope limited to transfers ingestion + behaviour profile only.

::contentReference[oaicite:0]{index=0}