You are working in the repo `fpl-radar`.

Implement Issue **#12.5**: Candidate generation narrowing to avoid hitting the 2000 truncation limit.

This is a follow-up improvement to Issue #12. The goal is to reduce the OUT×IN combinatorial explosion by shrinking the IN-player pool *before* generating candidates, using a cheap heuristic based on publicly available fields (no scoring engine required).

## Goal
Ensure `generateSingleTransferCandidates(...)` typically returns <= `maxCandidates` without blunt truncation by:
- Building a per-position IN pool
- Sorting that pool by a simple popularity proxy (`selectedByPercent`)
- Limiting to a configurable `N_PER_POSITION` (default 300)
- Generating candidates only from this narrowed pool

This should dramatically reduce candidate count while still capturing the most likely rival moves.

## Constraints
- Do NOT add ML, probability models, or new ingestion endpoints.
- Use only data already stored in DB (FplPlayer fields like `selectedByPercent`, `status`, etc.).
- Keep the change scoped: it should be a small refactor of candidate generation + a config constant.
- Maintain correctness: all generated candidates must still pass the same constraint checks (budget, 3-per-team, same-position, not already owned).

---

## Deliverables

### A) Config constants
Add:
- `src/prediction/constants.ts`

Export:
```ts
export const DEFAULT_MAX_CANDIDATES = 2000;
export const DEFAULT_IN_POOL_PER_POSITION = 300; // v1 narrowing
```
If you already have constants elsewhere, reuse/extend them.

B) Narrowed IN pool builder

Create:

- src/prediction/inPoolBuilder.ts

Export:

```ts
export async function buildInPoolByPosition(params: {
  ownedPlayerIds: Set<number>;
  positionIds: number[]; // the positions present in the squad
  perPositionLimit?: number; // default DEFAULT_IN_POOL_PER_POSITION
}): Promise<Map<number, Array<{
  playerId: number;
  teamId: number;
  positionId: number;
  nowCost: number;
  selectedByPercent: number | null;
  status: string;
}>>>
```

Implementation details:

- Query DB for each positionId (or query once with where positionId in (...) and group in-memory).

- Exclude players already owned.

- Sort each position pool by:

- - selectedByPercent descending (nulls treated as -1)

- Take top perPositionLimit.

- Keep status filtering permissive (do not exclude lots of players):

- - You MAY exclude obvious unavailable status if it’s clearly coded (e.g. status === "u"), but if unsure, don’t exclude. Add TODO.

- Return a Map<positionId, players[]>.

C) Refactor candidate generator to use narrowed pool

Update:

- src/prediction/candidateGenerator.ts

Changes:

1) Add optional params:

```ts
generateSingleTransferCandidates(params: {
  squad: SquadState;
  maxCandidates?: number;
  perPositionInPoolLimit?: number;
})
```

2) Replace the previous “scan all players” approach:

- Compute ownedPlayerIds, teamCounts

- Compute positionIdsInSquad

- Call buildInPoolByPosition(...)

- For each OUT player, only iterate over IN pool for that OUT player’s positionId

3) Keep existing constraint checks and stats counters. Update stats to include:

- inPoolPerPositionLimit (the configured limit)

- inPoolSizeByPosition (optional, useful for debugging)

4) Truncation behaviour:

- Keep the existing maxCandidates guard.

- With narrowing, truncation should be rare. If truncation still happens:

- - keep current behaviour (stop and set truncated: true)

D) Script update for debugging

Update src/scripts/generate-candidates.ts (Issue #12 script) to print:

- per-position pool sizes (before/after limiting)

- whether truncation occurred

Also allow env override:

- FPL_IN_POOL_LIMIT (number). If present, pass as perPositionInPoolLimit.

Acceptance Criteria

- Running pnpm predict:candidates for a real entry:

- - rarely hits truncation

- - still returns a good number of candidates (>0)

- Candidates remain valid (same constraints as before)

- Candidate generation is noticeably faster and memory usage lower

- IN pool narrowing is configurable by parameter and optional env var

Notes / Future extension (comment only)

- Later (after Issue #13 and #14), we can add a “Top-K keeper” based on a preScore:

- - preScore = sellPressure(out) + buyPull(in)

- - maintain heap/partial sort. But do NOT implement this now.

Implementation Order

1) Add constants

2) Implement buildInPoolByPosition

3) Refactor generator to use narrowed pools

4) Update script to show pool diagnostics

5) Run against a league entry and confirm truncation is reduced

Keep scope strictly to narrowing the IN pool before candidate generation.