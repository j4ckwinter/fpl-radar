You are working in the repo `fpl-radar`.

Implement Issue #9: Ingest classic Fantasy Premier League league standings by league ID and persist them to Postgres.

This builds on:
- The existing `FplClient.getLeagueStandings(...)`
- Prisma models created in Issue #8
- The ingestion pattern established for bootstrap-static

## Goal
Create an ingestion pipeline that:
- Fetches all entries in a classic league (handles pagination)
- Persists league metadata and league entries
- Is idempotent and safe to re-run
- Can be executed via a script and later reused by a worker job

This step should NOT fetch picks or transfers yet — standings only.

---

## Domain Concepts (important)
- A **League** represents a mini-league (classic league).
- A **LeagueEntry** represents a manager/team within that league.
- Standings change over time, but entry identity is stable (entry ID).
- We only care about the *current* standings for now (no historical snapshots yet).

---

## Deliverables

### A) Prisma schema changes

Extend `prisma/schema.prisma` with:

#### 1) `FplLeague`
- `id` Int @id (league ID from FPL)
- `name` String
- `createdAt` DateTime @default(now())
- `updatedAt` DateTime @updatedAt

#### 2) `FplLeagueEntry`
- `id` Int @id (entry ID from FPL)
- `leagueId` Int (FK → FplLeague)
- `entryName` String
- `playerName` String
- `rank` Int
- `lastRank` Int?
- `totalPoints` Int
- `updatedAt` DateTime @updatedAt

Indexes:
- index on `leagueId`
- optional composite index on `(leagueId, rank)`

Relations:
- FplLeague 1 → many FplLeagueEntry

After updating the schema, run:
```bash
pnpm exec prisma migrate dev --name fpl_league_standings

B) Ingestion logic

Create:

src/ingestion/leagueStandingsIngestion.ts

Export:

ingestLeagueStandings(params: {
  leagueId: number;
  logger: Logger;
}): Promise<{
  leagueId: number;
  leagueName: string;
  entriesCount: number;
}>

Responsibilities:

Fetch league standings from FPL using FplClient.getLeagueStandings

Handle pagination:

Continue fetching pages until has_next === false

Normalise data:

league id + name

entry id

entry_name → entryName

player_name → playerName

total → totalPoints

Upsert FplLeague

Upsert all FplLeagueEntry rows

Use upsert per entry OR createMany + update strategy

Use a transaction where appropriate

Return summary info (league name + entry count)

Do NOT:

Store historical ranks yet

Store event/GW-specific standings

Fetch picks or transfers

C) Script to run ingestion

Create:

src/scripts/ingest-league.ts

This script should:

Load env (import "dotenv/config")

Read FPL_LEAGUE_ID from env

Validate that it exists and is a number

Call ingestLeagueStandings

Log:

league id

league name

number of entries ingested

Add script to package.json:

"ingest:league": "tsx src/scripts/ingest-league.ts"
D) Idempotency expectations

Re-running:

pnpm ingest:league

should:

Not create duplicate leagues

Not create duplicate entries

Update ranks and total points correctly

E) Optional (nice-to-have, not required)

Add a small helper to delete league entries that are no longer present (league member left)

Log a warning if the league is very large (>100 entries)

Acceptance Criteria

League and entries appear in Postgres

Pagination is handled correctly

Script can be re-run safely

No downstream assumptions (no picks, no transfers yet)

Code is clean, readable, and follows existing ingestion patterns

Implementation Order (important)

Update Prisma schema and migrate

Implement ingestion logic

Add script + package.json command

Run against a real league ID and verify DB contents

Do all work directly in the repo. Keep scope limited to league standings only.