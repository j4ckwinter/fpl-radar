You are working in the repo `fpl-radar`.

Implement **Engine v1.1 – Step 2: Ingest future fixtures and add an upcoming fixture signal to scoring**.

## Context
Upcoming fixtures are one of the strongest predictors of transfers:
- Players with **good fixture runs** are more likely to be bought
- Players entering **bad fixture runs** are more likely to be sold

Right now, the engine does **not** consider future fixtures at all.
This task adds:
1) fixture ingestion (team-level),
2) a derived “upcoming fixture score”,
3) light integration into BUY and SELL scoring.

This must remain deterministic, explainable, and cheap to compute.

---

## Scope
- Ingest fixtures from the public FPL API
- Store fixtures in DB
- Derive a **team-level upcoming fixture difficulty score**
- Attach a **player-level upcomingFixtureScore** via teamId
- Use this score in:
  - BUY scoring (positive signal)
  - SELL scoring (negative signal for good runs, positive for bad runs)

Do NOT:
- Add xG / projections
- Add per-player historical performance
- Add heavy math or ML
- Change legality rules

---

## Deliverables

### A) DB schema for fixtures
Add a new Prisma model:
- `FplFixture`

Suggested fields:
```prisma
model FplFixture {
  id            Int      @id
  eventId       Int?
  teamHId       Int
  teamAId       Int
  teamHDifficulty Int
  teamADifficulty Int
  kickoffTime   DateTime?
  finished      Boolean

  @@index([eventId])
  @@index([teamHId])
  @@index([teamAId])
}
```

Notes:

- Difficulty values come directly from the FPL API (1–5)

- Store both home and away difficulties as provided

Run migration:

pnpm exec prisma migrate dev --name add_fixtures


B) Fixture ingestion

Create:

- src/ingest/fixtures.ts

Export:
```ts
export async function ingestFixtures(): Promise<void>
```

Implementation:

- Call GET /api/fixtures/

- Upsert fixtures by id

- Store:

- - event

- - home/away team ids

- - difficulties

- - kickoff_time

- - finished flag

Add script:
```json
"ingest:fixtures": "tsx src/ingest/fixtures.ts"
```


C) Upcoming fixture score derivation

Create:

- src/prediction/fixtures/upcomingScore.ts

Export:
```ts
export function computeUpcomingFixtureScore(params: {
  fixtures: Array<{
    eventId: number | null;
    teamId: number;
    difficulty: number; // 1–5
  }>;
  lookahead: number; // default 3
}): number
```

Rules:

- Consider next N fixtures only (default N = 3)

- Lower difficulty = better

- Example simple formula:
```ts
score = lookahead * 6 - sum(difficulty)
```

So:

- 3 easy fixtures (1,1,2) → high score

- 3 hard fixtures (4,5,5) → low or negative score

- Clamp result to a sensible range (e.g. -10 to +10).

Keep this simple and explainable.


D) Team-level aggregation

Create:

- src/prediction/fixtures/teamUpcomingScores.ts

Export:
```ts
export async function loadTeamUpcomingFixtureScores(params: {
  eventId: number;
  lookahead?: number; // default 3
}): Promise<Map<number, number>> // teamId → score
```

Implementation:

- Load fixtures from DB where:

- - eventId > currentEventId

- - finished = false

- For each team:

- - collect next N fixtures

- - compute score using helper above

- Return Map keyed by teamId


E) Attach to player features

Update feature extraction:

SELL features

- Add to SellCandidateScore.features:
```ts
upcomingFixtureScore: number | null
```
BUY features

- Add to BuyCandidateScore.features:
```ts
upcomingFixtureScore: number | null
```

Populate via:

- player.teamId → teamUpcomingScores.get(teamId)

If fixtures missing:

- set null

- reduce confidence / skip weighting

F) Scoring integration

Update constants:

BUY scoring

In src/prediction/buyScoring/constants.ts:
```ts
FIXTURE_GOOD_BONUS: number // e.g. +10
FIXTURE_BAD_PENALTY: number // e.g. -10
```

Apply:

- if upcomingFixtureScore >= +X → bonus

- if upcomingFixtureScore <= -X → penalty

SELL scoring

In src/prediction/sellScoring/constants.ts:
```ts
GOOD_FIXTURE_HOLD_PENALTY: number // reduces sell likelihood
BAD_FIXTURE_SELL_BONUS: number   // increases sell likelihood
```

Rules:

- Good upcoming run → less likely to sell

- Bad upcoming run → more likely to sell

Add clear reasons:

- "Favourable upcoming fixtures"

- "Difficult upcoming fixtures"

G) Tests

Add unit tests for:

- computeUpcomingFixtureScore

- Team aggregation with mocked fixtures

Test cases:

- Easy run produces positive score

- Hard run produces negative score

- Lookahead respected

- Missing fixtures handled gracefully

Acceptance Criteria

- Fixtures can be ingested and stored

- Upcoming fixture scores computed per team

- BUY scoring favours good runs

- SELL scoring penalises good runs

- Reasons clearly explain fixture impact

- No breaking changes to existing predictions

Implementation Order

- Add DB model + migration

- Add fixture ingestion

- Add upcoming fixture scoring helper

- Add team-level aggregation

- Attach to BUY/SELL features

- Integrate scoring + reasons

- Add tests

Keep the math simple and explainable. This is a signal, not a projection model.