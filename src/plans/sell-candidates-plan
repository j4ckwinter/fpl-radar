You are working in the repo `fpl-radar`.

Implement **Issue #13: Score likely sell candidates in rival squads**.

This step takes a rival’s current squad snapshot and produces a ranked list of “likely sells” with explainable reasons. Do NOT score buys yet (Issue #14) and do NOT compute OUT→IN probabilities yet (Issue #15).

Assume Issues #8–#12 exist:
- Reference data in DB (players/teams/positions/gameweeks)
- League entries exist
- Entry snapshots + picks exist for a target eventId
- Candidate generation exists (Issue #12), but this sell scoring must work even without generating IN candidates.

---

## Goal
Given:
- `leagueId`
- `entryId`
- `eventId`

Return a list of the entry’s owned players scored by “sell likelihood”.

Output:
- sorted list of owned players with:
  - `playerId`
  - `sellScore` (0..100 integer)
  - `reasons[]` (human readable strings)
  - `features` (numeric/boolean feature values for debugging)

The scoring must be:
- deterministic
- explainable
- easy to tune later (weights centralised)

---

## Inputs you can use (DB-only for this issue)
Use only what is already persisted in DB:
- From `FplPlayer`: `status`, `news`, `selectedByPercent`, `nowCost`, `teamId`, `positionId`, `webName` (if stored)
- From snapshot/picks: bench vs starting XI, captain/vice captain flags
- From gameweeks: resolve current/next if needed for scripts

Do NOT add new FPL API calls or new ingestion endpoints in this step.

---

## Deliverables

### A) Types
Create:
- `src/prediction/sellScoring/types.ts`

Define:
```ts
export interface SellCandidateScore {
  playerId: number;
  sellScore: number; // 0..100 integer
  reasons: string[];
  features: {
    isFlagged: boolean;
    status: string;
    hasNews: boolean;
    selectedByPercent: number | null;
    isBenched: boolean;
    isCaptainOrVice: boolean;
    nowCost: number;
  };
}
```

B) Centralised scoring weights

Create:

- src/prediction/sellScoring/constants.ts

Export something like:

```ts
export const SELL_SCORE = {
  BASE: 10,
  FLAGGED: 50,
  UNAVAILABLE_EXTRA: 20,
  BENCHED: 15,
  HAS_NEWS: 10,
  CAPTAIN_OR_VICE_PENALTY: 30,
  TEMPLATE_HOLD_PENALTY: 10,
  TEMPLATE_THRESHOLD: 30,
} as const;
```

C) Feature extraction

Create:

- src/prediction/sellScoring/features.ts

Export:

```ts
export function extractSellFeatures(params: {
  picks: Array<{
    playerId: number;
    pickPosition: number; // 1..15
    isCaptain: boolean;
    isViceCaptain: boolean;
  }>;
  playersById: Map<number, {
    status: string;
    news: string | null;
    selectedByPercent: number | null;
    nowCost: number;
  }>;
}): Map<number, SellCandidateScore["features"]>
```

Rules:

- isBenched: pickPosition > 11

- isCaptainOrVice: captain OR vice

- hasNews: news != null && news.trim().length > 0

- isFlagged: status in ["i","s","u","d"] OR hasNews === true

- - Keep this defensive. Add TODO to refine per FPL status meanings.

D) Scoring + reasons

Create:

- src/prediction/sellScoring/score.ts

Export:

```ts
export async function scoreSellCandidates(params: {
  leagueId: number;
  entryId: number;
  eventId: number;
  topN?: number; // default 15
}): Promise<{ scores: SellCandidateScore[] }>
```


Implementation steps:

1) Load the snapshot + picks for (leagueId, entryId, eventId):

- Prefer using loadSquadState from Issue #12 if it exposes picks metadata.

- If not, query Prisma directly for:

- - FplEntrySnapshot (bank optional)

- - FplEntryPick rows (15) including pickPosition, isCaptain, isViceCaptain

2) Load required fields from FplPlayer for those 15 playerIds.

3) Build playersById map and call extractSellFeatures.

4) Compute sellScore (0..100) using the heuristic below:

Suggested v1 heuristic (must be encoded via constants):

- Start with BASE

- If isFlagged => +FLAGGED

- If status === "u" => +UNAVAILABLE_EXTRA

- If isBenched => +BENCHED

- If hasNews => +HAS_NEWS (on top of flagged)

- If isCaptainOrVice => -CAPTAIN_OR_VICE_PENALTY

- If NOT flagged and selectedByPercent >= TEMPLATE_THRESHOLD => -TEMPLATE_HOLD_PENALTY

Clamp to [0, 100].

5) Attach reasons (stable, concise, not spammy):

- If flagged: "Flagged / availability concern"

- If status === "u": "Unavailable"

- If benched: "On the bench"

- If captain/vice: "Captain/vice captain"

- If template hold applied: "High-ownership template hold"

- If hasNews: include a short snippet:

- - News: <first 80 chars>… (truncate, remove newlines)

6) Sort descending by sellScore.

7) Return topN (default 15; but max is 15 anyway).


E) Exports

Create:

- src/prediction/sellScoring/index.ts exporting scoreSellCandidates.

Also export from src/prediction/index.ts (if you have a prediction barrel).

F) Script for manual verification

Create:

- src/scripts/score-sells.ts

Env vars:

- FPL_LEAGUE_ID (required)

- FPL_ENTRY_ID (required)

- FPL_EVENT_ID (optional; if missing resolve from DB by picking isNext else isCurrent)

Script should:

- load env (import "dotenv/config")

- call scoreSellCandidates

- print top 10 rows with:

- - player webName

- - score

- - reasons (comma-separated)

Add package.json script:

"predict:sells": "tsx src/scripts/score-sells.ts"


Acceptance Criteria

- pnpm predict:sells runs successfully for a real entry

- Returns a ranked list of owned players with scores + reasons

- Flagged / benched players are generally higher; captain/vice lower

- No external API calls added in this issue

- Weights are centralised and easy to tweak

Notes / TODOs

1) This is heuristic and intentionally explainable.

2) Later incorporate player performance (minutes/points) once we ingest player GW stats.

3) Refine FPL status meanings once verified.

Implementation Order

1) Types + constants

2) Load snapshot+picks and player fields from DB

3) Feature extraction

4) Scoring + reasons + sorting

5) Script + package.json

6) Run and spot-check sanity

Do all work directly in the repo. Keep scope strictly to SELL scoring only.
