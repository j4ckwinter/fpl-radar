You are working in the repo `fpl-radar`.

Implement Issue #12: Generate legal 1-transfer candidates per rival (within a league) for a given gameweek, using persisted snapshots/picks and reference data.

This step creates the “candidate generation” layer for the rival transfer prediction engine. It must be correct and explainable. Do NOT implement scoring/probabilities yet (that is Issue #13–#15).

Assume Issue #8–#11 are complete:
- Reference data persisted: players/teams/positions/gameweeks
- League standings persisted
- Entry snapshots + picks persisted for a target `eventId`
- Entry transfers persisted and behaviour profiles exist (optional input, not required here)

---

## Goal
Given:
- `leagueId`
- `entryId` (a rival manager in that league)
- `eventId` (gameweek snapshot)

Generate a set of legal single transfers `OUT -> IN` that the rival could make, subject to constraints:
- Budget constraint (bank + sell value >= buy price)
- Position constraint (OUT and IN same position) for v1 (no formation change modelling)
- Max 3 players per real team
- Can’t bring in a player already owned
- Must produce only valid 15-player squads

Output should include:
- candidate transfers list, each with:
  - outPlayerId
  - inPlayerId
  - estimatedCostDelta (in tenths)
  - resultingBank (tenths)
  - constraint checks (for debugging / later “reasons”)
- diagnostics: how many candidates were generated and why candidates were filtered

This will be used later by scoring/probability steps.

---

## Important simplifications for v1
- 1 transfer only (no double transfers)
- Same-position swap only
- Use current `nowCost` for buy price
- For sell price:
  - If we have per-entry “purchase price / selling price” from public API we can’t reliably; so v1 use `nowCost` as sell price too.
  - Document this as an approximation in code comments and output field naming (`estimatedSellPrice`).
- Do not model chips, wildcard, free hit
- Do not require knowing “free transfers remaining” (not reliably public)

---

## Deliverables

### A) Domain types
Create:
- `src/prediction/types.ts`

Define types:
```ts
export interface SquadState {
  entryId: number;
  leagueId: number;
  eventId: number;
  bank: number | null; // tenths
  players: Array<{ playerId: number; teamId: number; positionId: number; nowCost: number }>;
}

export interface TransferCandidate {
  outPlayerId: number;
  inPlayerId: number;
  outTeamId: number;
  inTeamId: number;
  positionId: number;
  estimatedSellPrice: number;
  buyPrice: number;
  estimatedCostDelta: number; // buy - sell
  resultingBank: number | null;
  checks: {
    budgetOk: boolean;
    alreadyOwned: boolean;
    teamLimitOk: boolean;
    positionOk: boolean;
  };
}
```

B) Squad loader

Create:

- src/prediction/squadLoader.ts

Export:

```ts
loadSquadState(params: { leagueId: number; entryId: number; eventId: number }): Promise<SquadState>
```

Implementation:

- Query FplEntrySnapshot by (leagueId, entryId, eventId)

- Load associated FplEntryPick rows (15)

- Join to FplPlayer to get:

- - teamId, positionId, nowCost

- Return SquadState

Validation:

- Ensure 15 players exist; if not, throw a typed error SquadNotFoundError / InvalidSquadError

C) Candidate generator

Create:

- src/prediction/candidateGenerator.ts

Export:

```ts
generateSingleTransferCandidates(params: {
  squad: SquadState;
  maxCandidates?: number; // default 2000 to protect performance
}): Promise<{
  candidates: TransferCandidate[];
  stats: {
    outPlayers: number;
    inPool: number;
    generated: number;
    filteredBudget: number;
    filteredOwned: number;
    filteredTeamLimit: number;
    filteredPosition: number;
    truncated: boolean;
  };
}>
```

Logic:

1. Build:

- ownedPlayerIds set

- teamCounts map teamId -> count in squad

2) Build an “in pool” list of all players from DB that are:

- available for transfer in general:

- - status not in a hard “unavailable” list (e.g. keep it permissive: allow all except maybe status === "u" if that exists; but don’t overfit; add TODO)

- not already owned

3) For each out-player in the squad (15 players):

- consider in-players with same positionId only

- for each in-player, check:

- - budgetOk: if bank is null, still generate but set resultingBank null and budgetOk true (so we don’t drop data)
else bank + estimatedSellPrice >= buyPrice

- - teamLimitOk:

- - - if inTeamId == outTeamId: always ok (team counts unchanged)

- - - else ensure (teamCounts[inTeamId] + 1) <= 3 AND (teamCounts[outTeamId] - 1) >= 0

- - alreadyOwned: ensure false by construction but keep check for safety

4) Create TransferCandidate with checks + computed fields

5) Stop if exceeding maxCandidates; set truncated true

Performance:

- Avoid O(15 * Nplayers) full scans if possible:

- - Query players grouped by positionId once:

- - - SELECT players WHERE positionId = X for each positionId present in squad

- Keep it simple but not naive; caching per run is fine.

D) Exports / wiring

Create:

- src/prediction/index.ts exporting the generator + loader

E) Script for manual verification

Create:

- src/scripts/generate-candidates.ts

Behaviour:

- load env (dotenv/config)

- require:

- - FPL_LEAGUE_ID

- - FPL_ENTRY_ID (one rival entry)

- - optional FPL_EVENT_ID (else pick “next/current” from DB gameweeks)

- Load squad state, generate candidates

- Print:

- - entryId, eventId, bank

- - number of candidates

- - show first 10 candidates (out -> in, delta, teamLimitOk, budgetOk)

Add package.json script:

"predict:candidates": "tsx src/scripts/generate-candidates.ts"

Acceptance Criteria

- Running pnpm predict:candidates produces a non-empty list for a real entry

- Candidates never include:

- - same in-player already owned

- - transfers that break 3-per-team constraint

- - position mismatches

- Budget constraint is enforced when bank is present (and clearly marked when unknown)

- Code is modular and readable with helper functions (team counts, checks)

- No scoring/probabilities are implemented

Notes / TODOs (include as comments)

- Sell price approximation (using nowCost) and future plan to improve if we can infer selling price

- Status/availability filtering should be refined later

- Formation-change candidates are out of scope for v1

Implementation Order

1) Add types

2) Implement squad loader (DB joins)

3) Implement generator (constraint checks + stats)

4) Add script and run against known league/entry

5) Verify constraints with a few spot checks

Do all work directly in the repo. Keep scope strictly to legal candidate generation.

::contentReference[oaicite:0]{index=0}