You are working in the repo `fpl-radar`.

Implement **Issue #14: Score likely buy candidates across player pool**.

This step produces a ranked list of “likely buys” for a rival entry (or globally) using ONLY persisted DB data (reference data + any derived signals you already store). Do NOT compute OUT→IN probabilities yet (Issue #15). This step should be explainable and easy to tune.

Assumptions:
- Issue #8 reference data exists in DB (players/teams/positions/gameweeks)
- Issue #9 league entries exist
- Issue #10 snapshots/picks exist (so we can exclude already-owned players and enforce 3-per-team later)
- Issue #11 behaviour profiles may exist (optional input)
- Issue #13 sell scoring exists (not required here)
- You likely DO NOT have per-player expected points or xG models yet, so v1 buy scoring should rely on available proxies:
  - `selectedByPercent` (ownership)
  - `nowCost` (price band)
  - availability/status/news
  - simple fixture/run signal (only if you already store fixtures; if not, skip)
  
If fixtures/projections are not yet in DB, keep buy scoring primarily “bandwagon + availability + affordability” and document as v1.

---

## Goal
Given:
- `leagueId`
- `entryId`
- `eventId`

Return a ranked list of players the rival is likely to buy soon.

Output:
- sorted list of buy candidates with:
  - `playerId`
  - `buyScore` (0..100 integer)
  - `reasons[]` (human readable)
  - `features` (debuggable values)

This will later be combined with sell scores and legality checks to produce transfer probabilities.

---

## Scope rules
- Exclude players already owned by the entry.
- Do not attempt to generate specific OUT→IN pairs here.
- Do not hit upstream FPL endpoints (DB-only).
- Keep it fast: avoid scanning all players with heavy per-row logic; use DB filtering and sensible limits.

---

## Deliverables

### A) Types + constants
Create:
- `src/prediction/buyScoring/types.ts`

```ts
export interface BuyCandidateScore {
  playerId: number;
  buyScore: number; // 0..100 integer
  reasons: string[];
  features: {
    isAvailable: boolean;
    status: string;
    hasNews: boolean;
    selectedByPercent: number | null;
    nowCost: number;
    positionId: number;
    teamId: number;
  };
}
```

Create:

- src/prediction/buyScoring/constants.ts

Suggested v1 weights:

```ts
export const BUY_SCORE = {
  BASE: 5,
  OWNERSHIP_BONUS_MAX: 45,     // scaled by selectedByPercent
  AVAILABLE_BONUS: 15,
  FLAGGED_PENALTY: 40,
  HAS_NEWS_PENALTY: 10,
  PRICE_VERY_HIGH_PENALTY: 10, // mild penalty to avoid always picking premiums in v1
  VERY_HIGH_PRICE_THRESHOLD: 120, // £12.0m (tenths)
  TOP_POOL_LIMIT: 500,         // max candidates to return for later pairing
} as const;
```

B) Owned player / team-count context loader

Create helper:

- src/prediction/buyScoring/context.ts

Export:

```ts
export async function loadBuyContext(params: {
  leagueId: number;
  entryId: number;
  eventId: number;
}): Promise<{
  ownedPlayerIds: Set<number>;
  teamCounts: Map<number, number>;
}>
```

Implementation:

- Load snapshot + picks for (leagueId, entryId, eventId)

- Join players to get teamId

- Build sets/maps

- Throw a typed error if snapshot missing

C) Candidate pool query (DB filtering)

Create:

- src/prediction/buyScoring/pool.ts

Export:

```ts
export async function loadBuyPool(params: {
  ownedPlayerIds: Set<number>;
  limit?: number; // default BUY_SCORE.TOP_POOL_LIMIT
}): Promise<Array<{
  id: number;
  teamId: number;
  positionId: number;
  nowCost: number;
  status: string;
  news: string | null;
  selectedByPercent: number | null;
  webName: string;
}>>
```

Rules:

- Exclude owned players (use NOT IN filter; if too large, filter in memory after fetching a broader set)

- Prefer ordering in DB by selectedByPercent desc nulls last to get “most likely buys” quickly

- Keep limit at 500 (configurable) to avoid scanning ~700 players every run

D) Feature extraction + scoring

Create:

- src/prediction/buyScoring/score.ts

Export:

```ts
export async function scoreBuyCandidates(params: {
  leagueId: number;
  entryId: number;
  eventId: number;
  limit?: number; // default 100 returned results
}): Promise<{ scores: BuyCandidateScore[] }>
```

Steps:

1) Load buy context (ownedPlayerIds + teamCounts)

2) Load candidate pool ordered by ownership (limit ~500)

3) For each player in pool:

- Determine:

- - hasNews (news non-empty)

- - isAvailable:

- - - treat status "a" as available; if unsure, define:

- - - - unavailable statuses: ["u"]

- - - - flagged statuses: ["i","s","d"]

- - - - else treat as available

- - - Keep defensive, add TODO to refine once status codes verified

4) Compute buyScore heuristic:

- Start BASE

- Ownership bonus:

- - if selectedByPercent exists:

- - - add scaled bonus: min(OWNERSHIP_BONUS_MAX, selectedByPercent * (OWNERSHIP_BONUS_MAX / 60))

- - - (so 60% ownership ~= max bonus)

- If isAvailable => +AVAILABLE_BONUS

- If flagged/unavailable => -FLAGGED_PENALTY (unavailable can use same or stronger)

- If hasNews => -HAS_NEWS_PENALTY (unless news is empty)

- If nowCost >= VERY_HIGH_PRICE_THRESHOLD => -PRICE_VERY_HIGH_PENALTY (mild)

- Clamp to [0, 100]

5) Attach reasons:

- "High ownership / template target"

- "Available to play"

- "Flagged / availability concern" (if penalised)

- "News present"

- "Very high price"

6) Sort by buyScore desc and return top limit (default 100)

Important: Do NOT enforce 3-per-team here yet; that happens when pairing with OUT players in Issue #15/16. But do include teamId in features so it’s easy later.

E) Exports

Create:

src/prediction/buyScoring/index.ts exporting scoreBuyCandidates.
Also export from src/prediction/index.ts if you have a barrel.

F) Script for manual verification

Create:

- src/scripts/score-buys.ts

Env vars:

- FPL_LEAGUE_ID required

- FPL_ENTRY_ID required

- FPL_EVENT_ID optional (resolve next/current from DB if missing)

Script should:

- call scoreBuyCandidates({ limit: 25 })

- print top 25:

- - webName, teamId/positionId (or map to short names if available), cost, ownership, score, reasons

Add package.json script:

"predict:buys": "tsx src/scripts/score-buys.ts"


Acceptance Criteria

- pnpm predict:buys runs successfully for a real entry

- Output excludes owned players

- Output is ranked and explainable (scores + reasons)

- No external API calls added (DB-only)

- Performance: runs quickly (pool limited, DB ordered)

- Weights are centralised and easy to tweak

Notes / TODOs

- This v1 buy scoring is intentionally proxy-based (ownership/availability).

- Later replace/augment with projections and fixture difficulty once those datasets are ingested.

- Status code meanings should be verified and refined.

Implementation Order

1) Types + constants

2) Context loader (owned players)

3) Pool query (top players by ownership)

4) Scoring + reasons + sorting

5) Script + package.json

6) Run and sanity-check top results

Do all work directly in the repo. Keep scope strictly to BUY scoring only.